# Mephi_Labs_AISD2023–2024

Лабораторные работы по курсу **«Алгоритмы и структуры данных» (AISD)**  
НИЯУ МИФИ, 2023–2024 учебный год.

Автор: **@SeniorCUCUMBERDeveloper**  
Основной язык реализации: **C**.

---

## Структура репозитория

- `3a/lab3` — ЛР №3A — ассоциативная таблица с версиями (release)
- `3b/lab3b` — ЛР №3B — хеш-таблица с версиями и бинарным файлом
- `4a/4a` — ЛР №4A — двоичное дерево поиска (BST)
- `4b/lab4b` — ЛР №4B — B-дерево (B-tree) по строковым ключам
- `5/5` — ЛР №5 — ориентированный взвешенный граф

Ниже — какие структуры данных реализованы в каждой работе и какой функционал поддерживается.

---

## 3A. Лабораторная работа №3A — ассоциативная таблица с версиями (release)

**Папка:** `3a/lab3`  

**Основные структуры (из `t.h`):**

- `info` — хранимая информация (значение)
- `Node` — элемент списка с данными и ссылками
- `KeySpace` — информация о ключах и их версиях
- `Table` — сама таблица

**Структура данных:**

Собственная реализация ассоциативной таблицы `Table`, в которой хранятся пары:

> ключ (строка) → данные

Для одного и того же ключа может существовать **несколько версий (release)**, то есть таблица поддерживает «версии» записей.

**Основной функционал:**

- Ввод/чтение:
  - динамическое чтение строк (`myreadline`, `myread`);
  - безопасный ввод чисел (`getInt`).
- Операции с таблицей:
  - `push` — вставка нового элемента (новая запись или новая версия существующего ключа);
  - `searchTable` — поиск записи по ключу;
  - `copy` — копирование записи (создание ещё одного release для ключа);
  - `pop` — удаление по ключу (всех версий);
  - `poprelease` — удаление **конкретной версии** по ключу и номеру release;
  - `individual1` — поиск конкретной версии по паре `(key, release)`;
  - `printTable` — печать содержимого таблицы;
  - `removeTable` — полное освобождение памяти.
- Импорт:
  - `intxt` — загрузка таблицы из текстового файла.

Через `dialog.h` реализовано текстовое меню: добавление, поиск, удаление, печать, импорт и т.д.

---

## 3B. Лабораторная работа №3B — хеш-таблица с версиями и бинарным файлом

**Папка:** `3b/lab3b`  

**Основные структуры (из `t.h`):**

- `KeySpace` — ячейка хеш-таблицы
- `Table` — сама хеш-таблица
- `ans` — структура для возврата множества результатов

**Структура данных:**

Реализована **хеш-таблица** по строковым ключам с возможностью иметь несколько версий (release) для одного ключа.

Используются:

- функция хеширования `hash(char* str, int del)`;
- механизмы переразмеривания и перехеширования (`UpdateTable`, `ratio`, `searchNexteasy`).

**Основной функционал:**

- Основные операции:
  - `push` — вставка новой записи (ключ + данные) в хеш-таблицу;
  - `find` — поиск по ключу;
  - `findALLkey` — поиск всех записей по ключу (все release);
  - `findRelease` — поиск конкретной версии по `key + release`;
  - `allpop` — удаление всех версий данного ключа;
  - `poprelease` — удаление только одной версии (конкретного release);
  - `correctTable` — изменение/коррекция существующей записи.
- Импорт/экспорт:
  - `fwritebin` — запись таблицы в бинарный файл;
  - `freadbin` — чтение таблицы из бинарного файла.
- Служебные:
  - `UpdateTable` — изменение размера таблицы и перехеширование;
  - `ratio` — оценка заполненности (load factor);
  - `searchNexteasy` — поиск следующего простого числа для размера таблицы;
  - `myreadline` — динамическое чтение строк.

ЛР №3B — это развитие ЛР №3A: переход от линейной структуры таблицы к полноценной **хеш-таблице с версиями и поддержкой бинарного формата**.

---

## 4A. Лабораторная работа №4A — двоичное дерево поиска (BST)

**Папка:** `4a/4a`  

**Основные структуры (из `lib.h`, `queue.h`):**

- `Node` — вершина дерева (ключ + строка-значение)
- `answ` — структура/массив для результатов поиска
- `Stack` — стек для обхода дерева

**Структура данных:**

Классическое **двоичное дерево поиска (Binary Search Tree)**, где:

- ключ — целое число;
- значение — строка (`char* info`).

**Основной функционал дерева:**

- Создание и базовые операции:
  - `createNode` — создание новой вершины;
  - `push` — вставка узла по ключу (BST-вставка);
  - `pop` — удаление узла по ключу;
  - `search` — поиск по ключу;
  - `MiNode` — поиск минимального элемента в поддереве;
  - `deleted` — полное удаление дерева и освобождение памяти.
- Обход и вывод:
  - `printTree` — печать дерева с учётом глубины (визуально в виде дерева);
  - `sorted` / `sorted_b` — проверки корректности свойств дерева (упорядоченность).
- Дополнительные операции:
  - `uniqsearch` — поиск с накоплением результатов в `answ`;
  - `indot` — генерация `.dot` файла для визуализации дерева через Graphviz;
  - `searchFORtiming` — поиск для замеров времени;
  - `Fileread` — чтение дерева из файла.
- Стек для обходов (`queue.h`):
  - `add` / `del` — push/pop для собственного стека обхода.

Через `dialog.h` реализовано меню: добавление, поиск, удаление, обход, проверка свойств, экспорт в `.dot`, чтение из файла, дополнительные задания.

---

## 4B. Лабораторная работа №4B — B-дерево (B-tree) по строковым ключам

**Папка:** `4b/lab4b`  

**Основные структуры:**

- `data` — запись (ключ + информация)
- `answ` — структура для результатов поиска
- `node` — узел B-дерева

**Структура данных:**

Реализовано **B-дерево** по строковым ключам:

- каждый узел содержит несколько ключей и дочерних указателей;
- дерево сбалансировано по высоте;
- операции вставки и удаления поддерживают свойства B-дерева (распределение ключей, расщепление/слияние узлов).

**Основной функционал:**

- Создание и освобождение:
  - `treecreate` — создание дерева;
  - `freeTree`, `freenode` — освобождение всех узлов.
- Вставка:
  - `InsertTree` — основная функция вставки;
  - `insertnonfull` — вставка в неполный узел;
  - `split` — расщепление дочернего узла при переполнении.
- Удаление:
  - `deleteTree` — удаление ключа;
  - `handle_root_with_single_child` — обработка случая, когда корень имеет одного ребёнка после удаления;
  - `delete_from_leaf_node` — удаление из листа.
- Поиск:
  - `search` — поиск по ключу с возвращением всех найденных записей через `answ`;
  - `uniqsearch` — поиск уникальной записи по ключу;
  - `Min` / `Max` — поиск минимального/максимального ключа;
  - `search_for_insert`, `search_insert` — служебные функции поиска позиции для вставки.
- Обход:
  - `travel` — обход дерева для вывода/отладки.

ЛР №4B — классическая реализация **B-дерева с поддержкой всех основных операций: поиск, вставка, удаление, обход**.

---

## 5. Лабораторная работа №5 — ориентированный взвешенный граф

**Папка:** `5/5`  

**Основные структуры (из `lib.h`):**

- `Edge` — ребро графа
- `Point` — вершина
- `Graph` — граф
- `reb` — вспомогательная структура для хранения/обработки рёбер

**Структура данных:**

Реализован **ориентированный взвешенный граф**:

- вершины (`Point`);
- списки смежности для рёбер (`Edge` / `reb`);
- возможна матрица смежности для отдельных задач.

**Основной функционал:**

- Создание и уничтожение:
  - `create` — создание пустого графа;
  - `destroyGraph` — освобождение графа;
  - `deleteALLVer` — удаление всех вершин.
- Операции над вершинами и рёбрами:
  - `addVertex` — добавить вершину (по строковому ключу/имени);
  - `addEdges` — добавить ориентированное ребро между вершинами с весом;
  - `deleteEdge` — удалить ребро;
  - `deleteVerticals` — удалить вершину вместе со всеми инцидентными рёбрами;
  - `New_name` — переименовать вершину.
- Матрица смежности:
  - `matr` — построение матрицы смежности;
  - `printMatrix` — вывод матрицы;
  - `deleteMatr` — освобождение матрицы.
- Алгоритмы на графах:
  - `path` — поиск пути/кратчайших путей от заданной вершины (с выводом в файлы);
  - `DFS` — обход в глубину;
  - `findConnectedComponents` — поиск компонент связности.
- Визуализация и дополнительные функции:
  - `indot` — генерация `.dot` файла для визуализации через Graphviz;
  - `dop1`, `dop2`, `dop3` — дополнительные задания/модификации графа.

В `dialog.h` реализовано интерактивное меню для пошаговой работы с графом: добавление вершин и рёбер, отображение, матрица, пути, DFS, компоненты связности, экспорт в `.dot` и т.д.

---

## Как собирать и запускать

Общий шаблон (если в папке есть `Makefile`):

```bash
cd <путь_к_лабе>   # например, 3a/lab3
make               # сборка
./<имя_программы>  # имя исполняемого файла смотрите в Makefile
```

Если `Makefile` нет:

```bash
cd <путь_к_лабе>
gcc -std=c11 -Wall -Wextra -O2 main.c -o lab
./lab
```

(замените `main.c` и `lab` на реальные имена файлов в соответствующей директории.)

---
